import scala.collection.mutable.{ArrayBuffer, HashMap, HashSet, Queue}
import java.util.Scanner
    
object Solution {
    var m = 0
    var n = 0
    var debug = false
    var blocks: Array[Block] = null
        
    final class Point(val i: Int, val j: Int) {
        override def toString = " (" + i + "," + j + ")"
        override def hashCode = i * n + j
        override def equals(other: Any) = other match { 
            case that: Point => this.i == that.i && this.j == that.j
            case _ => false
        }
        def neighbors = List(
            new Point(i - 1, j), new Point(i, j - 1), 
            new Point(i + 1, j), new Point(i, j + 1)
        )
        def +(that: Point): Point = new Point(this.i + that.i, this.j + that.j)
        def -(that: Point): Point = new Point(this.i - that.i, this.j - that.j)
        
        // TODO (maybe): Move this in blocks, and add a check with the width/height of the block
        def isInside = i >= 0 && i < m && j >= 0 && j < n
    }
    
    final class Node(val blockId: Int, val positions: Seq[Point], val distance: Int, val previous: Node) {
        override def toString = bKey + previous.positions(blockId) + moved
        override def hashCode = hash
        //positions.foldLeft(0)( (hash: Int, point: Point) => 36 * hash + point.hashCode )
        override def equals(other: Any): Boolean = other match { 
            case that: Node => {
                for (i <- 0 until board.length) {
                    val x = this.board(i)
                    val y = that.board(i)
                    if (x != y && (x == -1 || y == -1 || KeyStore.bConf(x) != KeyStore.bConf(y))) return false
                }
                return true
            }
            case _ => false
        }
        
        val board = {
            val b = Array.fill(n * m)(-1)
            for (i <- 0 until positions.length) {
                val pos = positions(i)
                for (p <- blocks(i).points) {
                    b((p + pos).hashCode) = i
                }
            }
            //val b = (0 until positions.length) map( i => positions(i) -> i )
            b
            //val b = positions.zipWithIndex.map ( (p: Point, i: Int) => p -> i) toMap
        }
        
        val hash = {
            var h = 0
            /*for (i <- 0 until positions.length) {
                h = 31 * h + KeyStore.bConf(i)
                h = 7 * h + positions(i).hashCode
            }*/
            for (i <- 0 until board.length) {
                val x = board(i)
                if (x != -1) {
                    h = 31 * h + KeyStore.bConf(x)
                    h = 7 * h + i
                }
            }
            h
        }
        
        def bKey = KeyStore.keys(blockId)
        def moved = positions(blockId)
    }
    
    final class Block(val id: Int, positions: List[Point]) {
        val initial = positions.reduce( (p1: Point, p2: Point) => new Point(Math.min(p1.i, p2.i), Math.min(p1.j, p2.j)) )
        val points = positions.map( (p) => p - initial )
        
        override def toString = KeyStore.keys(id) + points.foldLeft("")( (str: String, point: Point) => str + point.toString )
        override def hashCode = points.foldLeft(0)( (hash: Int, point: Point) => 36 * hash + point.hashCode )
        // TODO: override equals
            
        def moves(pos: Point, board: Array[Int]): Array[Point] = {
            val positions = new HashSet[Point]
            moveFrom(positions, pos, pos, board)

            return positions.toArray // TODO return the set
        }
        
        def moveFrom(positions: HashSet[Point], current: Point, pos: Point, board: Array[Int]) {
            // pos is the current valid position
            for (p <- pos.neighbors) { // for each neighbors
                if (p.isInside && !positions.contains(p) && p != current && canMove(p, board)) {
                    positions += p
                    moveFrom(positions, current, p, board)
                }
            }
        }
        
        def canMove(t: Point, board: Array[Int]): Boolean = {
            for (p <- points) {
                val np = p + t
                if (!np.isInside || (board(np.hashCode) != -1 && board(np.hashCode) != id)) {
                    return false
                }
            }
            return true
        }
    }
    
    object KeyStore {
        val map = new HashMap[String, Int]
        val bHashes = new HashMap[Int, Int]
        val bConf = new Array[Int](36)
        val keys = new Array[String](36)
        
        var size = 0
        var bSize = 1

        def index(key: String): Int = {
            if (!map.contains(key)) {
                keys(size) = key
                map(key) = size
                size += 1
            }
            map(key)
        }
        
        // Indexed hashs
        def put(block: Block) {
            val hash = block.hashCode
            if (bHashes.contains(hash)) {
                val bId = bHashes(hash)
                bConf(block.id) = bConf(bId)
            } else {
                val c = bSize
                bHashes(hash) = block.id
                bConf(block.id) = c
                bSize += 1
            }
        }
        
        def markTarget(target: Int) {
            bConf(target) = bSize
            bSize += 1
        }
    }
    
    def displayPath(node: Node) {
        // compute path
        // TODO maybe: directly display path recursively
        val path = new Array[Node](node.distance + 1)
        var n = node
        while (n != null) {
            path(n.distance) = n
            n = n.previous
        }
        // Display path
        println(node.distance)
        for (i <- 1 until path.length) {
            println(path(i))
        }
    }
    
    def displayBoard(board: HashMap[Point, Int]) {
        val empty = "." * KeyStore.keys(0).length
        for (i <- 0 until m) {
            for (j <- 0 until n) {
                val p = new Point(i, j)
                print(if (board.contains(p)) KeyStore.keys(board(p)) else empty)
                print(" ")
            }
            println("")
        }
    }
    
    def parseBoard(in: Scanner): Array[Array[String]] = {
        val bPoints = new Array[ArrayBuffer[Point]](36)
        in.nextLine() // Skip the first Line Feed
        val board = new Array[Array[String]](m)
            
        for (i <- 0 until m) {
            board(i) = in.nextLine().split(" ")
            for (j <- 0 until n) {
                val key = board(i)(j)
                if (key != "." * key.length) { // So as ".B" doesn't fail
                    val bId = KeyStore.index(key)
                    if (bPoints(bId) == null) {
                        bPoints(bId) = new ArrayBuffer[Point]
                    }
                    bPoints(bId) += new Point(i, j)
                }
            }
        }
        
        blocks = new Array[Block](KeyStore.size)
        for (i <- 0 until KeyStore.size) {
            val block = new Block(i, bPoints(i).toList)
            KeyStore.put(block)
            blocks(i) = block
        }
        return board
    }
    
    def initialPositions(blocks: Array[Block]): Seq[Point] = {
        val positions = new Array[Point](blocks.length)
        
        for (i <- 0 until blocks.length) {
            positions(i) = blocks(i).initial
        }
        return positions
    }
    
    def main(args: Array[String]) {
        val in = new Scanner(System.in)
        m = in.nextInt()
        n = in.nextInt()
        val board = parseBoard(in)
        val target = KeyStore.index(in.next())
        val goal = new Point(in.nextInt(), in.nextInt())

        KeyStore.markTarget(target)
        in.close()
            
        // Getting rid of some trivial cases
        if (blocks(target).initial == goal) {
            println(0)
        } else if (blocks.size == 1) {
            println(1)
            println(KeyStore.keys(target) + blocks(0).initial + goal)
        } else {
            // Allow to detect positions already visited
            val nodes = HashSet[Node]()
            val fifo = new Queue[Node]
            val root = new Node(-1, initialPositions(blocks), 0, null)
                
            var distanceToGoal = 201
            var currentDistance = 1
            var previous = root
            var solution = root
            
            nodes += root
                
            while (currentDistance < distanceToGoal) {
                for (i <- 0 until blocks.length) {
                    if (i != previous.blockId) {
                        val block = blocks(i)
                        val position = previous.positions(block.id)
                        val moves = block.moves(position, previous.board)
                        
                        for (move <- moves) {
                            val positions = previous.positions.updated(i, move)
                            val node = new Node(i, positions, currentDistance, previous)
                            //val hash = node.hashCode
                            
                            // Skip if already visited
                            if (!nodes.contains(node)) {
                                nodes += node
                                if (i == target && move == goal) { // Solution!
                                    solution = node
                                    distanceToGoal = currentDistance
                                } else {
                                    // TODO compute board here
                                    fifo.enqueue(node)
                                }
                            }
                        }
                    }
                }
                if (fifo.isEmpty) { // No more moves available
                    currentDistance = distanceToGoal
                } else {
                    previous = fifo.dequeue
                    currentDistance = previous.distance + 1
                }
            }
            
            displayPath(solution)
        }
    }
}
